// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;
use crate::*;

#[derive(Clone)]
pub struct ImmutableAddPPToFractionResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableAddPPToFractionResults {
    pub fn frac_id(&self) -> ScImmutableHash {
		ScImmutableHash::new(self.proxy.root(RESULT_FRAC_ID))
	}

    pub fn pp(&self) -> ImmutableProductPass {
		ImmutableProductPass { proxy: self.proxy.root(RESULT_PP) }
	}
}

#[derive(Clone)]
pub struct MutableAddPPToFractionResults {
	pub(crate) proxy: Proxy,
}

impl MutableAddPPToFractionResults {
    pub fn frac_id(&self) -> ScMutableHash {
		ScMutableHash::new(self.proxy.root(RESULT_FRAC_ID))
	}

    pub fn pp(&self) -> MutableProductPass {
		MutableProductPass { proxy: self.proxy.root(RESULT_PP) }
	}
}

#[derive(Clone)]
pub struct ImmutableCreateFractionResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableCreateFractionResults {
    pub fn frac_id(&self) -> ScImmutableHash {
		ScImmutableHash::new(self.proxy.root(RESULT_FRAC_ID))
	}
}

#[derive(Clone)]
pub struct MutableCreateFractionResults {
	pub(crate) proxy: Proxy,
}

impl MutableCreateFractionResults {
    pub fn frac_id(&self) -> ScMutableHash {
		ScMutableHash::new(self.proxy.root(RESULT_FRAC_ID))
	}
}

#[derive(Clone)]
pub struct ImmutableCreatePPResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableCreatePPResults {
    pub fn id(&self) -> ScImmutableHash {
		ScImmutableHash::new(self.proxy.root(RESULT_ID))
	}
}

#[derive(Clone)]
pub struct MutableCreatePPResults {
	pub(crate) proxy: Proxy,
}

impl MutableCreatePPResults {
    pub fn id(&self) -> ScMutableHash {
		ScMutableHash::new(self.proxy.root(RESULT_ID))
	}
}

#[derive(Clone)]
pub struct ImmutableCreateRecyclateResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableCreateRecyclateResults {
    pub fn fraction(&self) -> ImmutableFraction {
		ImmutableFraction { proxy: self.proxy.root(RESULT_FRACTION) }
	}

    pub fn recy_id(&self) -> ScImmutableHash {
		ScImmutableHash::new(self.proxy.root(RESULT_RECY_ID))
	}
}

#[derive(Clone)]
pub struct MutableCreateRecyclateResults {
	pub(crate) proxy: Proxy,
}

impl MutableCreateRecyclateResults {
    pub fn fraction(&self) -> MutableFraction {
		MutableFraction { proxy: self.proxy.root(RESULT_FRACTION) }
	}

    pub fn recy_id(&self) -> ScMutableHash {
		ScMutableHash::new(self.proxy.root(RESULT_RECY_ID))
	}
}

#[derive(Clone)]
pub struct ImmutableDeletePPResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableDeletePPResults {
    pub fn pp(&self) -> ImmutableProductPass {
		ImmutableProductPass { proxy: self.proxy.root(RESULT_PP) }
	}
}

#[derive(Clone)]
pub struct MutableDeletePPResults {
	pub(crate) proxy: Proxy,
}

impl MutableDeletePPResults {
    pub fn pp(&self) -> MutableProductPass {
		MutableProductPass { proxy: self.proxy.root(RESULT_PP) }
	}
}

#[derive(Clone)]
pub struct ImmutableGetAmountOfRequiredFundsResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableGetAmountOfRequiredFundsResults {
    pub fn token_required(&self) -> ScImmutableUint64 {
		ScImmutableUint64::new(self.proxy.root(RESULT_TOKEN_REQUIRED))
	}
}

#[derive(Clone)]
pub struct MutableGetAmountOfRequiredFundsResults {
	pub(crate) proxy: Proxy,
}

impl MutableGetAmountOfRequiredFundsResults {
    pub fn token_required(&self) -> ScMutableUint64 {
		ScMutableUint64::new(self.proxy.root(RESULT_TOKEN_REQUIRED))
	}
}

#[derive(Clone)]
pub struct ImmutableGetDonationAddressResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableGetDonationAddressResults {
    pub fn donation_address(&self) -> ScImmutableAgentID {
		ScImmutableAgentID::new(self.proxy.root(RESULT_DONATION_ADDRESS))
	}
}

#[derive(Clone)]
pub struct MutableGetDonationAddressResults {
	pub(crate) proxy: Proxy,
}

impl MutableGetDonationAddressResults {
    pub fn donation_address(&self) -> ScMutableAgentID {
		ScMutableAgentID::new(self.proxy.root(RESULT_DONATION_ADDRESS))
	}
}

#[derive(Clone)]
pub struct ImmutableGetFractionResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableGetFractionResults {
    pub fn frac_composition(&self) -> ImmutableFracCompositions {
		ImmutableFracCompositions { proxy: self.proxy.root(RESULT_FRAC_COMPOSITION) }
	}

    pub fn fraction(&self) -> ImmutableFraction {
		ImmutableFraction { proxy: self.proxy.root(RESULT_FRACTION) }
	}
}

#[derive(Clone)]
pub struct MutableGetFractionResults {
	pub(crate) proxy: Proxy,
}

impl MutableGetFractionResults {
    pub fn frac_composition(&self) -> MutableFracCompositions {
		MutableFracCompositions { proxy: self.proxy.root(RESULT_FRAC_COMPOSITION) }
	}

    pub fn fraction(&self) -> MutableFraction {
		MutableFraction { proxy: self.proxy.root(RESULT_FRACTION) }
	}
}

#[derive(Clone)]
pub struct ImmutableGetMaterialsResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableGetMaterialsResults {
    pub fn compositions(&self) -> ImmutableCompositions {
		ImmutableCompositions { proxy: self.proxy.root(RESULT_COMPOSITIONS) }
	}
}

#[derive(Clone)]
pub struct MutableGetMaterialsResults {
	pub(crate) proxy: Proxy,
}

impl MutableGetMaterialsResults {
    pub fn compositions(&self) -> MutableCompositions {
		MutableCompositions { proxy: self.proxy.root(RESULT_COMPOSITIONS) }
	}
}

#[derive(Clone)]
pub struct ImmutableGetOwnerResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableGetOwnerResults {
    pub fn owner(&self) -> ScImmutableAgentID {
		ScImmutableAgentID::new(self.proxy.root(RESULT_OWNER))
	}
}

#[derive(Clone)]
pub struct MutableGetOwnerResults {
	pub(crate) proxy: Proxy,
}

impl MutableGetOwnerResults {
    pub fn owner(&self) -> ScMutableAgentID {
		ScMutableAgentID::new(self.proxy.root(RESULT_OWNER))
	}
}

#[derive(Clone)]
pub struct ImmutableGetPPResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableGetPPResults {
    pub fn ppname(&self) -> ScImmutableString {
		ScImmutableString::new(self.proxy.root(RESULT_PPNAME))
	}

    pub fn ppresult(&self) -> ImmutableProductPass {
		ImmutableProductPass { proxy: self.proxy.root(RESULT_PPRESULT) }
	}
}

#[derive(Clone)]
pub struct MutableGetPPResults {
	pub(crate) proxy: Proxy,
}

impl MutableGetPPResults {
    pub fn ppname(&self) -> ScMutableString {
		ScMutableString::new(self.proxy.root(RESULT_PPNAME))
	}

    pub fn ppresult(&self) -> MutableProductPass {
		MutableProductPass { proxy: self.proxy.root(RESULT_PPRESULT) }
	}
}

#[derive(Clone)]
pub struct ImmutableGetRecyclateResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableGetRecyclateResults {
    pub fn recy_composition(&self) -> ImmutableRecyCompositions {
		ImmutableRecyCompositions { proxy: self.proxy.root(RESULT_RECY_COMPOSITION) }
	}

    pub fn recyclate(&self) -> ImmutableRecyclate {
		ImmutableRecyclate { proxy: self.proxy.root(RESULT_RECYCLATE) }
	}
}

#[derive(Clone)]
pub struct MutableGetRecyclateResults {
	pub(crate) proxy: Proxy,
}

impl MutableGetRecyclateResults {
    pub fn recy_composition(&self) -> MutableRecyCompositions {
		MutableRecyCompositions { proxy: self.proxy.root(RESULT_RECY_COMPOSITION) }
	}

    pub fn recyclate(&self) -> MutableRecyclate {
		MutableRecyclate { proxy: self.proxy.root(RESULT_RECYCLATE) }
	}
}

#[derive(Clone)]
pub struct ImmutableGetTokenPerPackageResults {
	pub(crate) proxy: Proxy,
}

impl ImmutableGetTokenPerPackageResults {
    pub fn token_per_package(&self) -> ScImmutableUint64 {
		ScImmutableUint64::new(self.proxy.root(RESULT_TOKEN_PER_PACKAGE))
	}
}

#[derive(Clone)]
pub struct MutableGetTokenPerPackageResults {
	pub(crate) proxy: Proxy,
}

impl MutableGetTokenPerPackageResults {
    pub fn token_per_package(&self) -> ScMutableUint64 {
		ScMutableUint64::new(self.proxy.root(RESULT_TOKEN_PER_PACKAGE))
	}
}
