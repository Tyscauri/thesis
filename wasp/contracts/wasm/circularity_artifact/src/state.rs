// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;

use crate::*;

#[derive(Clone)]
pub struct MapHashToImmutableCompositions {
	pub(crate) proxy: Proxy,
}

impl MapHashToImmutableCompositions {
    pub fn get_compositions(&self, key: &ScHash) -> ImmutableCompositions {
        ImmutableCompositions { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapHashToImmutableFracCompositions {
	pub(crate) proxy: Proxy,
}

impl MapHashToImmutableFracCompositions {
    pub fn get_frac_compositions(&self, key: &ScHash) -> ImmutableFracCompositions {
        ImmutableFracCompositions { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapHashToImmutableFraction {
	pub(crate) proxy: Proxy,
}

impl MapHashToImmutableFraction {
    pub fn get_fraction(&self, key: &ScHash) -> ImmutableFraction {
        ImmutableFraction { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapAgentIDToImmutableUint64 {
	pub(crate) proxy: Proxy,
}

impl MapAgentIDToImmutableUint64 {
    pub fn get_uint64(&self, key: &ScAgentID) -> ScImmutableUint64 {
        ScImmutableUint64::new(self.proxy.key(&agent_id_to_bytes(key)))
    }
}

#[derive(Clone)]
pub struct MapHashToImmutableProductPass {
	pub(crate) proxy: Proxy,
}

impl MapHashToImmutableProductPass {
    pub fn get_product_pass(&self, key: &ScHash) -> ImmutableProductPass {
        ImmutableProductPass { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapHashToImmutableRecyCompositions {
	pub(crate) proxy: Proxy,
}

impl MapHashToImmutableRecyCompositions {
    pub fn get_recy_compositions(&self, key: &ScHash) -> ImmutableRecyCompositions {
        ImmutableRecyCompositions { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapHashToImmutableRecyclate {
	pub(crate) proxy: Proxy,
}

impl MapHashToImmutableRecyclate {
    pub fn get_recyclate(&self, key: &ScHash) -> ImmutableRecyclate {
        ImmutableRecyclate { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct ArrayOfImmutableAgentID {
	pub(crate) proxy: Proxy,
}

impl ArrayOfImmutableAgentID {
    pub fn length(&self) -> u32 {
        self.proxy.length()
    }

    pub fn get_agent_id(&self, index: u32) -> ScImmutableAgentID {
        ScImmutableAgentID::new(self.proxy.index(index))
    }
}

#[derive(Clone)]
pub struct Immutablecircularity_artifactState {
	pub(crate) proxy: Proxy,
}

impl Immutablecircularity_artifactState {
    pub fn compositions(&self) -> MapHashToImmutableCompositions {
		MapHashToImmutableCompositions { proxy: self.proxy.root(STATE_COMPOSITIONS) }
	}

    pub fn donation_address(&self) -> ScImmutableAgentID {
		ScImmutableAgentID::new(self.proxy.root(STATE_DONATION_ADDRESS))
	}

    pub fn frac_compositions(&self) -> MapHashToImmutableFracCompositions {
		MapHashToImmutableFracCompositions { proxy: self.proxy.root(STATE_FRAC_COMPOSITIONS) }
	}

    pub fn fractions(&self) -> MapHashToImmutableFraction {
		MapHashToImmutableFraction { proxy: self.proxy.root(STATE_FRACTIONS) }
	}

    pub fn owner(&self) -> ScImmutableAgentID {
		ScImmutableAgentID::new(self.proxy.root(STATE_OWNER))
	}

    pub fn price_per_mg(&self) -> ScImmutableUint64 {
		ScImmutableUint64::new(self.proxy.root(STATE_PRICE_PER_MG))
	}

    pub fn producers_balances(&self) -> MapAgentIDToImmutableUint64 {
		MapAgentIDToImmutableUint64 { proxy: self.proxy.root(STATE_PRODUCERS_BALANCES) }
	}

    pub fn productpasses(&self) -> MapHashToImmutableProductPass {
		MapHashToImmutableProductPass { proxy: self.proxy.root(STATE_PRODUCTPASSES) }
	}

    pub fn recy_compositions(&self) -> MapHashToImmutableRecyCompositions {
		MapHashToImmutableRecyCompositions { proxy: self.proxy.root(STATE_RECY_COMPOSITIONS) }
	}

    pub fn recyclates(&self) -> MapHashToImmutableRecyclate {
		MapHashToImmutableRecyclate { proxy: self.proxy.root(STATE_RECYCLATES) }
	}

    pub fn recyclers(&self) -> ArrayOfImmutableAgentID {
		ArrayOfImmutableAgentID { proxy: self.proxy.root(STATE_RECYCLERS) }
	}

    pub fn recyclers_balances(&self) -> MapAgentIDToImmutableUint64 {
		MapAgentIDToImmutableUint64 { proxy: self.proxy.root(STATE_RECYCLERS_BALANCES) }
	}

    pub fn share_recycler(&self) -> ScImmutableUint8 {
		ScImmutableUint8::new(self.proxy.root(STATE_SHARE_RECYCLER))
	}

    pub fn sorters(&self) -> ArrayOfImmutableAgentID {
		ArrayOfImmutableAgentID { proxy: self.proxy.root(STATE_SORTERS) }
	}

    pub fn token_to_donate(&self) -> ScImmutableUint64 {
		ScImmutableUint64::new(self.proxy.root(STATE_TOKEN_TO_DONATE))
	}
}

#[derive(Clone)]
pub struct MapHashToMutableCompositions {
	pub(crate) proxy: Proxy,
}

impl MapHashToMutableCompositions {
    pub fn clear(&self) {
        self.proxy.clear_map();
    }

    pub fn get_compositions(&self, key: &ScHash) -> MutableCompositions {
        MutableCompositions { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapHashToMutableFracCompositions {
	pub(crate) proxy: Proxy,
}

impl MapHashToMutableFracCompositions {
    pub fn clear(&self) {
        self.proxy.clear_map();
    }

    pub fn get_frac_compositions(&self, key: &ScHash) -> MutableFracCompositions {
        MutableFracCompositions { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapHashToMutableFraction {
	pub(crate) proxy: Proxy,
}

impl MapHashToMutableFraction {
    pub fn clear(&self) {
        self.proxy.clear_map();
    }

    pub fn get_fraction(&self, key: &ScHash) -> MutableFraction {
        MutableFraction { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapAgentIDToMutableUint64 {
	pub(crate) proxy: Proxy,
}

impl MapAgentIDToMutableUint64 {
    pub fn clear(&self) {
        self.proxy.clear_map();
    }

    pub fn get_uint64(&self, key: &ScAgentID) -> ScMutableUint64 {
        ScMutableUint64::new(self.proxy.key(&agent_id_to_bytes(key)))
    }
}

#[derive(Clone)]
pub struct MapHashToMutableProductPass {
	pub(crate) proxy: Proxy,
}

impl MapHashToMutableProductPass {
    pub fn clear(&self) {
        self.proxy.clear_map();
    }

    pub fn get_product_pass(&self, key: &ScHash) -> MutableProductPass {
        MutableProductPass { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapHashToMutableRecyCompositions {
	pub(crate) proxy: Proxy,
}

impl MapHashToMutableRecyCompositions {
    pub fn clear(&self) {
        self.proxy.clear_map();
    }

    pub fn get_recy_compositions(&self, key: &ScHash) -> MutableRecyCompositions {
        MutableRecyCompositions { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct MapHashToMutableRecyclate {
	pub(crate) proxy: Proxy,
}

impl MapHashToMutableRecyclate {
    pub fn clear(&self) {
        self.proxy.clear_map();
    }

    pub fn get_recyclate(&self, key: &ScHash) -> MutableRecyclate {
        MutableRecyclate { proxy: self.proxy.key(&hash_to_bytes(key)) }
    }
}

#[derive(Clone)]
pub struct ArrayOfMutableAgentID {
	pub(crate) proxy: Proxy,
}

impl ArrayOfMutableAgentID {
	pub fn append_agent_id(&self) -> ScMutableAgentID {
		ScMutableAgentID::new(self.proxy.append())
	}

	pub fn clear(&self) {
        self.proxy.clear_array();
    }

    pub fn length(&self) -> u32 {
        self.proxy.length()
    }

    pub fn get_agent_id(&self, index: u32) -> ScMutableAgentID {
        ScMutableAgentID::new(self.proxy.index(index))
    }
}

#[derive(Clone)]
pub struct Mutablecircularity_artifactState {
	pub(crate) proxy: Proxy,
}

impl Mutablecircularity_artifactState {
    pub fn as_immutable(&self) -> Immutablecircularity_artifactState {
		Immutablecircularity_artifactState { proxy: self.proxy.root("") }
	}

    pub fn compositions(&self) -> MapHashToMutableCompositions {
		MapHashToMutableCompositions { proxy: self.proxy.root(STATE_COMPOSITIONS) }
	}

    pub fn donation_address(&self) -> ScMutableAgentID {
		ScMutableAgentID::new(self.proxy.root(STATE_DONATION_ADDRESS))
	}

    pub fn frac_compositions(&self) -> MapHashToMutableFracCompositions {
		MapHashToMutableFracCompositions { proxy: self.proxy.root(STATE_FRAC_COMPOSITIONS) }
	}

    pub fn fractions(&self) -> MapHashToMutableFraction {
		MapHashToMutableFraction { proxy: self.proxy.root(STATE_FRACTIONS) }
	}

    pub fn owner(&self) -> ScMutableAgentID {
		ScMutableAgentID::new(self.proxy.root(STATE_OWNER))
	}

    pub fn price_per_mg(&self) -> ScMutableUint64 {
		ScMutableUint64::new(self.proxy.root(STATE_PRICE_PER_MG))
	}

    pub fn producers_balances(&self) -> MapAgentIDToMutableUint64 {
		MapAgentIDToMutableUint64 { proxy: self.proxy.root(STATE_PRODUCERS_BALANCES) }
	}

    pub fn productpasses(&self) -> MapHashToMutableProductPass {
		MapHashToMutableProductPass { proxy: self.proxy.root(STATE_PRODUCTPASSES) }
	}

    pub fn recy_compositions(&self) -> MapHashToMutableRecyCompositions {
		MapHashToMutableRecyCompositions { proxy: self.proxy.root(STATE_RECY_COMPOSITIONS) }
	}

    pub fn recyclates(&self) -> MapHashToMutableRecyclate {
		MapHashToMutableRecyclate { proxy: self.proxy.root(STATE_RECYCLATES) }
	}

    pub fn recyclers(&self) -> ArrayOfMutableAgentID {
		ArrayOfMutableAgentID { proxy: self.proxy.root(STATE_RECYCLERS) }
	}

    pub fn recyclers_balances(&self) -> MapAgentIDToMutableUint64 {
		MapAgentIDToMutableUint64 { proxy: self.proxy.root(STATE_RECYCLERS_BALANCES) }
	}

    pub fn share_recycler(&self) -> ScMutableUint8 {
		ScMutableUint8::new(self.proxy.root(STATE_SHARE_RECYCLER))
	}

    pub fn sorters(&self) -> ArrayOfMutableAgentID {
		ArrayOfMutableAgentID { proxy: self.proxy.root(STATE_SORTERS) }
	}

    pub fn token_to_donate(&self) -> ScMutableUint64 {
		ScMutableUint64::new(self.proxy.root(STATE_TOKEN_TO_DONATE))
	}
}
